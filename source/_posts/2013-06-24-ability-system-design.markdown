---
layout: post
title: "技能脚本系统设计"
date: 2013-06-24 08:59
comments: true
categories: 
---

**Author**: Tuz (youngtrips@mail.com)
<br>
**Date**: 06.21.2013

###概述

针对现有技能系统发送消息过大, C++和lua交互频繁, 客户端功能服务器化, 触发器抽象粒度太小, 数据更新同步等问题进行脚本系统重构优化. 通过分析现有技能实现抽象出技能框架(技能引擎), 实现控制基本技能流程, 同时加入事件进制, 如攻击, 受伤等事件, 进而希望能够丰富技能同时使天赋的实现比较优雅.

###技能系统文件系统组织

* data (配置文件所在)
	+ skill (技能实例配置)
	+ buff (BUFF实例配置)
	+ talent (天赋实例配置)
	+ metadata (基本数据/元数据配置)
		- chapion.lua (各个职业基本数值配置)
		- monster.lua (各个类别怪物基本数值配置)
		- level.lua  (职业等级基本数值配置)
		- skill.lua  (各个技能基本数值配置)
* engine (技能框架,控制技能实例的运行及包含技能的公共函数等)
* lib (与具体游戏逻辑无关的公共库模块,包括基本计算几何计算等)
* skill (各个技能实例执行逻辑文件)
* buff (各个BUFF实例执行逻辑文件)
* talent (各个天赋实例执行逻辑)
* ai (怪物Ai逻辑)
* test (模块测试例程)

###系统基本结构

技能系统主要分为如下几个部分:

1. 事件系统: 由C++实现事件管理系统并提供给lua层注册事件及抛出事件的接口函数, C++每tick处理每个对象的事件队列；
2. 属性更新系统: 由C++实现对象属性更新机制并提供给lua层压入需要更新属性集的借口函数以实现lua上层逻辑勿需关系属性同步消息的发送；
3. 对象属性管理系统: 在lua层实现玩家对象及怪物对象属性及包含的技能属性的管理以减少lua访问对象属性时与C++层的交互调用；
4. 技能引擎(框架): 抽象出技能的公共部分, 将技能分解为几个阶段以控制技能实例的运行.

###事件系统

![eventbox](/images/ability-design/eventbox.png)

由C++层在当前触发器基础之上(改变当前触发器使用方式)封装具体类型的游戏事件系统, 每个游戏对象有自己的事件队列, 对象在Lua层通过接口函数可以注册事件或者在技能引擎模块中通过接口函数发送产生的游戏事件.

事件的组成:

1. 外部事件, 独立于技能体系, 不依赖于特定的技能产生, 主要由系统功能产生的, 主要包括:
	
	1. 时间事件: 定时器触发的事件
	2. 碰撞事件: 由移动碰撞产生的事件

2. 内部事件, 由技能各个模块执行过程中产生的, 主要有:

	1. 技能释放和被释放事件
	2. 攻击和被攻击事件
	3. 暴击和被暴击事件
	4. 死亡和被击杀事件
	5. 闪避和被闪避事件


###属性更新系统

C++层实现一套脏属性更新机制, 提供给lua层添加更新属性请求的接口函数(该函数主要由脚本底层调用, 上层逻辑不直接调用), 属性更新系统定时或即时的编码变化的属性值给客户端.

###对象属性管理系统

C++层创建对象后将会在lua层创建对应的管理对象(包含需要在lua层管理的对象属性, 技能及BUFF), 可是说是取消现有PT访问的进制, 但可以保持现有PT访问的方式实现上层对PT访问的透明性. lua中对象继承关系如下图所示:

![objs](/images/ability-design/objs.png)

其中Creature中skills包含该对象所有技能实例的属性集, 其技能属性集继承对应的技能配置表, 当技能实例发生修改属性时该技能属性集会有对应新的属性值以实现COW机制, 例如:

{% codeblock lang:lua %}
	function inherit(sub,super)
		setmetatable(sub,
     	{ __index=function(t,k)
             local ret=super[k]
             sub[k]=ret
             return ret
     	end } )
	end
	local a = {x = 1, y = 2}
	local b = {}
	inherit(b, a) -- b继承a两个成语x,y
	b.x = 3		  -- b将会有独立于a的成员x, 其值为3

{% endcodeblock %}

对象身上BUFF实例属性集管理与技能类似.


###技能引擎

从客户端表现上来看,技能可以看成是一个连续的, 有时间限制的事件序列. 在这个时间线上, 会出现一些关键事件, 例如伤害, 发射飞弹或其他, 所以这些技能事件才是该技能真正需要在客户端－服务器, 客户端－客户端之间传递的信息, 每个客户端都可以根据这些关键信息还原出技能的连续信号(模拟技能过程). 该技能引擎由客户端的消息进行驱动, 引擎通过发送技能事件给客户端, 客户端通过收到的技能事件决定客户端的技能表现(如吟唱, 特效及播放动作等). 服务器端每个技能实例由基本的OnEnter(), OnFire()及OnEnd()等回调函数组成.

服务器端将技能流程主要分解为三个阶段:

1. 技能开始(Enter): 施法前判定,回调技能实例OnEnter()及产生OnEnter事件通知客户端；
2. 技能执行(Fire): 技能释放过程,根据技能实例类型获取目标对象并回调技能实例OnFire()及产生OnFire事件通知客户端；
3. 技能结束(End): 技能结束过程,回调技能实例OnEnd()及产生OnEnd事件通知客户端.

客户端技能流程与服务器类似:

1. 技能触发阶段(Enter): 有玩家输入触发执行, 产生Enter事件请求服务器；
2. 技能开始(OnEnter): 客户端接收OnEnter事件执行进行吟唱, 动作播放及特效绑定等；
3. 技能释放(OnFire): 客户端接收OnFire事件执行伤害数值显示, 动作播放及特效绑定等；
4. 技能结束(OnEnd): 客户端接收OnEnd事执行技能结束清理逻辑, 如特性清理, 动作重置等.

技能实例执行时序图如下所示:

![skill_engine](/images/ability-design/skill_engine.png)

Detail of Engine:

![engine_detail](/images/ability-design/engine-detail.png)

服务器端技能实例主要包含:

1. OnAdd() 当技能被添加到对象身上时执行
2. OnDel() 当技能从对象身上移除时执行
3. OnUpgrade() 当技能升级时执行
4. OnEnter()
5. OnFire()
6. OnEnd()

###天赋系统

天赋可以归结为一种特殊的技能, 所以天赋实例与技能实例有着相同的组成成份. 天赋的驱动由技能引擎产生的各种事件进行驱动(如技能CD前后事件, 攻击前后事件, 资源消耗前后事件及伤害结算前后事件等).

